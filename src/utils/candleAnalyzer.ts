import { Candle } from './binanceClient';

export interface CandleMetrics {
  body: number;
  range: number;
  upperWick: number;
  lowerWick: number;
  isGreen: boolean;
  isRed: boolean;
  open: number;
  high: number;
  low: number;
  close: number;
}

export interface TrendAnalysis {
  ema50: number;
  ema200: number;
  isUptrend: boolean;
  isDowntrend: boolean;
  currentPrice: number;
}

export function analyzeCand(candle: Candle): CandleMetrics {
  const open = parseFloat(candle.open);
  const high = parseFloat(candle.high);
  const low = parseFloat(candle.low);
  const close = parseFloat(candle.close);

  const body = Math.abs(close - open);
  const range = high - low;
  const upperWick = high - Math.max(open, close);
  const lowerWick = Math.min(open, close) - low;
  const isGreen = close > open;
  const isRed = close < open;

  return {
    body,
    range,
    upperWick,
    lowerWick,
    isGreen,
    isRed,
    open,
    high,
    low,
    close,
  };
}

/**
 * –†–∞—Å—á–µ—Ç EMA (Exponential Moving Average)
 */
export function calculateEMA(candles: Candle[], period: number): number {
  if (candles.length < period) {
    console.warn(`‚ö†Ô∏è [EMA] –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–≤–µ—á–µ–π –¥–ª—è EMA${period}: ${candles.length} < ${period}`);
    return 0;
  }

  const closes = candles.map((c) => parseFloat(c.close));
  const multiplier = 2 / (period + 1);

  // –ü–µ—Ä–≤–∞—è SMA –∫–∞–∫ –Ω–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞
  let ema = closes.slice(0, period).reduce((sum, val) => sum + val, 0) / period;

  // –†–∞—Å—á–µ—Ç EMA –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–≤–µ—á–µ–π
  for (let i = period; i < closes.length; i++) {
    ema = (closes[i] - ema) * multiplier + ema;
  }

  return ema;
}

/**
 * –ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ EMA 50 –∏ EMA 200
 */
export function analyzeTrend(candles: Candle[]): TrendAnalysis {
  const ema50 = calculateEMA(candles, 50);
  const ema200 = calculateEMA(candles, 200);
  const currentPrice = parseFloat(candles[candles.length - 1].close);

  const isUptrend = currentPrice > ema50 && ema50 > ema200;
  const isDowntrend = currentPrice < ema50 && ema50 < ema200;

  console.log(`üìä [Trend] Price: ${currentPrice.toFixed(2)}, EMA50: ${ema50.toFixed(2)}, EMA200: ${ema200.toFixed(2)} | Uptrend: ${isUptrend}, Downtrend: ${isDowntrend}`);

  return {
    ema50,
    ema200,
    isUptrend,
    isDowntrend,
    currentPrice,
  };
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞, –±—ã–ª –ª–∏ —Ä–µ–∑–∫–∏–π —Ä–æ—Å—Ç/–ø–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º
 * (–¥–µ—Ç–µ–∫—Ç–∏—Ä—É–µ—Ç profit-taking –ø–∞—Ç—Ç–µ—Ä–Ω—ã, –∫–æ—Ç–æ—Ä—ã–µ —á–∞—Å—Ç–æ fail)
 */
export function hasSharpMoveBefore(candles: Candle[], direction: 'LONG' | 'SHORT'): boolean {
  if (candles.length < 5) return false;

  // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3-5 —Å–≤–µ—á–µ–π –ü–ï–†–ï–î —Ç–µ–∫—É—â–µ–π
  const recentCandles = candles.slice(-5, -1);
  let consecutiveLargeCandles = 0;

  for (const candle of recentCandles) {
    const metrics = analyzeCand(candle);
    const bodyPercent = metrics.body / metrics.range;
    const isLargeBody = bodyPercent > 0.6;

    if (direction === 'LONG') {
      // –ò—â–µ–º –ø–æ–¥—Ä—è–¥ –∏–¥—É—â–∏–µ –∑–µ–ª–µ–Ω—ã–µ —Å–≤–µ—á–∏ —Å –±–æ–ª—å—à–∏–º–∏ —Ç–µ–ª–∞–º–∏
      if (metrics.isGreen && isLargeBody) {
        consecutiveLargeCandles++;
      } else {
        consecutiveLargeCandles = 0;
      }
    } else {
      // –ò—â–µ–º –ø–æ–¥—Ä—è–¥ –∏–¥—É—â–∏–µ –∫—Ä–∞—Å–Ω—ã–µ —Å–≤–µ—á–∏ —Å –±–æ–ª—å—à–∏–º–∏ —Ç–µ–ª–∞–º–∏
      if (metrics.isRed && isLargeBody) {
        consecutiveLargeCandles++;
      } else {
        consecutiveLargeCandles = 0;
      }
    }
  }

  const hasSharpMove = consecutiveLargeCandles >= 3;
  
  if (hasSharpMove) {
    console.log(`‚ö†Ô∏è [Sharp Move] –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ ${consecutiveLargeCandles} –ø–æ–¥—Ä—è–¥ –±–æ–ª—å—à–∏—Ö —Å–≤–µ—á–µ–π –ø–µ—Ä–µ–¥ ${direction} –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º - –≤–æ–∑–º–æ–∂–Ω–æ profit-taking!`);
  }

  return hasSharpMove;
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—ä–µ–º–∞ (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—ã—à–µ —Å—Ä–µ–¥–Ω–µ–≥–æ)
 */
export function isVolumeAboveAverage(candles: Candle[]): boolean {
  if (candles.length < 21) return true; // –ï—Å–ª–∏ –º–∞–ª–æ –¥–∞–Ω–Ω—ã—Ö, –Ω–µ —Ñ–∏–ª—å—Ç—Ä—É–µ–º

  const volumes = candles.map((c) => parseFloat(c.volume));
  // –ü–æ—Å–ª–µ–¥–Ω–∏–µ 20 —Å–≤–µ—á–µ–π –î–û —Ç–µ–∫—É—â–µ–π: –±–µ—Ä–µ–º —Å –∏–Ω–¥–µ–∫—Å–∞ -21 –¥–æ -1 (–Ω–µ –≤–∫–ª—é—á–∞—è -1)
  const last20Volumes = volumes.slice(volumes.length - 21, volumes.length - 1);
  const avgVolume = last20Volumes.reduce((sum, vol) => sum + vol, 0) / last20Volumes.length;
  const currentVolume = volumes[volumes.length - 1];

  const isAboveAverage = currentVolume > avgVolume;

  console.log(`üìä [Volume] Current: ${currentVolume.toFixed(0)}, Avg(${last20Volumes.length}): ${avgVolume.toFixed(0)} | Above avg: ${isAboveAverage}`);

  return isAboveAverage;
}

export interface SRZone {
  type: 'support' | 'resistance';
  price: number;
  touches: number; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Å–∞–Ω–∏–π
  strength: 'weak' | 'medium' | 'strong'; // weak=2, medium=3-4, strong=5+
}

export interface SRAnalysis {
  nearestSupport: SRZone | null;
  nearestResistance: SRZone | null;
  allZones: SRZone[];
}

export interface PatternResult {
  detected: boolean;
  type?: 'pinbar_buy' | 'pinbar_sell' | 'fakey_buy' | 'fakey_sell' | 'ppr_buy' | 'ppr_sell' | 'engulfing_buy' | 'engulfing_sell';
  direction?: 'LONG' | 'SHORT';
  entryPrice?: number;
  srAnalysis?: SRAnalysis; // –î–æ–±–∞–≤–ª—è–µ–º S/R –∑–æ–Ω—ã
  score?: number; // –î–æ–±–∞–≤–ª—è–µ–º scoring
}

/**
 * –ü–æ–∏—Å–∫ Swing High (–ª–æ–∫–∞–ª—å–Ω—ã–π –º–∞–∫—Å–∏–º—É–º)
 * –°–≤–µ—á–∞ —è–≤–ª—è–µ—Ç—Å—è Swing High, –µ—Å–ª–∏ 2 —Å–≤–µ—á–∏ —Å–ª–µ–≤–∞ –∏ 2 —Å–ø—Ä–∞–≤–∞ –∏–º–µ—é—Ç –ú–ï–ù–¨–®–ò–ô –º–∞–∫—Å–∏–º—É–º
 */
function findSwingHighs(candles: Candle[], lookback: number = 2): number[] {
  const swingHighs: number[] = [];
  
  for (let i = lookback; i < candles.length - lookback; i++) {
    const currentHigh = parseFloat(candles[i].high);
    let isSwingHigh = true;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º lookback —Å–≤–µ—á–µ–π —Å–ª–µ–≤–∞ –∏ —Å–ø—Ä–∞–≤–∞
    for (let j = 1; j <= lookback; j++) {
      const leftHigh = parseFloat(candles[i - j].high);
      const rightHigh = parseFloat(candles[i + j].high);
      
      if (leftHigh >= currentHigh || rightHigh >= currentHigh) {
        isSwingHigh = false;
        break;
      }
    }
    
    if (isSwingHigh) {
      swingHighs.push(currentHigh);
    }
  }
  
  return swingHighs;
}

/**
 * –ü–æ–∏—Å–∫ Swing Low (–ª–æ–∫–∞–ª—å–Ω—ã–π –º–∏–Ω–∏–º—É–º)
 * –°–≤–µ—á–∞ —è–≤–ª—è–µ—Ç—Å—è Swing Low, –µ—Å–ª–∏ 2 —Å–≤–µ—á–∏ —Å–ª–µ–≤–∞ –∏ 2 —Å–ø—Ä–∞–≤–∞ –∏–º–µ—é—Ç –ë–û–õ–¨–®–ò–ô –º–∏–Ω–∏–º—É–º
 */
function findSwingLows(candles: Candle[], lookback: number = 2): number[] {
  const swingLows: number[] = [];
  
  for (let i = lookback; i < candles.length - lookback; i++) {
    const currentLow = parseFloat(candles[i].low);
    let isSwingLow = true;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º lookback —Å–≤–µ—á–µ–π —Å–ª–µ–≤–∞ –∏ —Å–ø—Ä–∞–≤–∞
    for (let j = 1; j <= lookback; j++) {
      const leftLow = parseFloat(candles[i - j].low);
      const rightLow = parseFloat(candles[i + j].low);
      
      if (leftLow <= currentLow || rightLow <= currentLow) {
        isSwingLow = false;
        break;
      }
    }
    
    if (isSwingLow) {
      swingLows.push(currentLow);
    }
  }
  
  return swingLows;
}

/**
 * –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —É—Ä–æ–≤–Ω–µ–π –≤ –∑–æ–Ω—ã (clustering)
 * –£—Ä–æ–≤–Ω–∏ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö tolerance% –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è –≤ –æ–¥–Ω—É –∑–æ–Ω—É
 */
function clusterLevels(levels: number[], tolerance: number = 0.005): SRZone[] {
  if (levels.length === 0) return [];
  
  const sortedLevels = [...levels].sort((a, b) => a - b);
  const zones: SRZone[] = [];
  
  let currentZone: number[] = [sortedLevels[0]];
  
  for (let i = 1; i < sortedLevels.length; i++) {
    const level = sortedLevels[i];
    const zoneCenter = currentZone.reduce((sum, l) => sum + l, 0) / currentZone.length;
    const diff = Math.abs(level - zoneCenter) / zoneCenter;
    
    if (diff <= tolerance) {
      // –£—Ä–æ–≤–µ–Ω—å –±–ª–∏–∑–∫–æ –∫ —Ç–µ–∫—É—â–µ–π –∑–æ–Ω–µ - –¥–æ–±–∞–≤–ª—è–µ–º
      currentZone.push(level);
    } else {
      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–æ–Ω—É –∏–∑ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã—Ö —É—Ä–æ–≤–Ω–µ–π
      if (currentZone.length >= 2) {
        const avgPrice = currentZone.reduce((sum, l) => sum + l, 0) / currentZone.length;
        const touches = currentZone.length;
        const strength: 'weak' | 'medium' | 'strong' = 
          touches >= 5 ? 'strong' : touches >= 3 ? 'medium' : 'weak';
        
        zones.push({
          type: 'support', // –¢–∏–ø –æ–ø—Ä–µ–¥–µ–ª–∏–º –ø–æ–∑–∂–µ
          price: avgPrice,
          touches,
          strength,
        });
      }
      
      currentZone = [level];
    }
  }
  
  // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–æ–Ω—É
  if (currentZone.length >= 2) {
    const avgPrice = currentZone.reduce((sum, l) => sum + l, 0) / currentZone.length;
    const touches = currentZone.length;
    const strength: 'weak' | 'medium' | 'strong' = 
      touches >= 5 ? 'strong' : touches >= 3 ? 'medium' : 'weak';
    
    zones.push({
      type: 'support',
      price: avgPrice,
      touches,
      strength,
    });
  }
  
  return zones;
}

/**
 * –ê–Ω–∞–ª–∏–∑ S/R –∑–æ–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ 200 —Å–≤–µ—á–µ–π
 */
export function analyzeSRZones(candles: Candle[]): SRAnalysis {
  if (candles.length < 50) {
    return {
      nearestSupport: null,
      nearestResistance: null,
      allZones: [],
    };
  }
  
  const currentPrice = parseFloat(candles[candles.length - 1].close);
  
  // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ —ç–∫—Å—Ç—Ä–µ–º—É–º—ã
  const swingHighs = findSwingHighs(candles);
  const swingLows = findSwingLows(candles);
  
  console.log(`üîç [S/R] Found ${swingHighs.length} swing highs, ${swingLows.length} swing lows`);
  
  // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –≤ –∑–æ–Ω—ã
  const resistanceZones = clusterLevels(swingHighs, 0.005).map(z => ({ ...z, type: 'resistance' as const }));
  const supportZones = clusterLevels(swingLows, 0.005).map(z => ({ ...z, type: 'support' as const }));
  
  // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∑–æ–Ω—ã —Å 3+ –∫–∞—Å–∞–Ω–∏—è–º–∏ (—Å–∏–ª—å–Ω—ã–µ –∏ —Å—Ä–µ–¥–Ω–∏–µ)
  const strongResistances = resistanceZones.filter(z => z.touches >= 3 && z.price > currentPrice);
  const strongSupports = supportZones.filter(z => z.touches >= 3 && z.price < currentPrice);
  
  // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–∏–µ –∑–æ–Ω—ã
  const nearestResistance = strongResistances.length > 0
    ? strongResistances.reduce((closest, zone) => 
        Math.abs(zone.price - currentPrice) < Math.abs(closest.price - currentPrice) ? zone : closest
      )
    : null;
  
  const nearestSupport = strongSupports.length > 0
    ? strongSupports.reduce((closest, zone) => 
        Math.abs(zone.price - currentPrice) < Math.abs(closest.price - currentPrice) ? zone : closest
      )
    : null;
  
  const allZones = [...strongResistances, ...strongSupports];
  
  console.log(`üìä [S/R] Found ${allZones.length} strong zones (3+ touches)`);
  if (nearestSupport) {
    console.log(`   üìç Nearest Support: ${nearestSupport.price.toFixed(4)} (${nearestSupport.touches} touches, ${nearestSupport.strength})`);
  }
  if (nearestResistance) {
    console.log(`   üìç Nearest Resistance: ${nearestResistance.price.toFixed(4)} (${nearestResistance.touches} touches, ${nearestResistance.strength})`);
  }
  
  return {
    nearestSupport,
    nearestResistance,
    allZones,
  };
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–ª–∏–∑–æ—Å—Ç–∏ –ø–∞—Ç—Ç–µ—Ä–Ω–∞ –∫ S/R –∑–æ–Ω–µ
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (null –µ—Å–ª–∏ –Ω–µ—Ç –∑–æ–Ω—ã)
 */
export function getDistanceToZone(price: number, zone: SRZone | null): number | null {
  if (!zone) return null;
  return Math.abs(price - zone.price) / zone.price;
}

export class PatternDetector {
  detectPinBar(candles: Candle[]): PatternResult {
    if (candles.length < 1) return { detected: false };

    const C0 = analyzeCand(candles[candles.length - 1]);

    // –õ–û–ù–ì: –ó–µ–ª–µ–Ω–∞—è —Å–≤–µ—á–∞, –¥–ª–∏–Ω–Ω—ã–π –Ω–∏–∂–Ω–∏–π —Ñ–∏—Ç–∏–ª—å
    if (C0.lowerWick >= 2 * C0.body && C0.lowerWick >= 2 * C0.upperWick) {
      const upperThird = C0.low + 0.66 * C0.range;
      const closeInUpperThird = C0.close >= upperThird;
      const smallBody = C0.body <= 0.35 * C0.range;

      if (closeInUpperThird && smallBody && C0.isGreen) {
        console.log(`‚úÖ [Pattern] Pin Bar BUY detected (GREEN candle)`);
        return {
          detected: true,
          type: 'pinbar_buy',
          direction: 'LONG',
          entryPrice: C0.close,
        };
      }
    }

    // –®–û–†–¢: –ö—Ä–∞—Å–Ω–∞—è —Å–≤–µ—á–∞, –¥–ª–∏–Ω–Ω—ã–π –≤–µ—Ä—Ö–Ω–∏–π —Ñ–∏—Ç–∏–ª—å
    if (C0.upperWick >= 2 * C0.body && C0.upperWick >= 2 * C0.lowerWick) {
      const lowerThird = C0.high - 0.66 * C0.range;
      const closeInLowerThird = C0.close <= lowerThird;
      const smallBody = C0.body <= 0.35 * C0.range;

      if (closeInLowerThird && smallBody && C0.isRed) {
        console.log(`‚úÖ [Pattern] Pin Bar SELL detected (RED candle)`);
        return {
          detected: true,
          type: 'pinbar_sell',
          direction: 'SHORT',
          entryPrice: C0.close,
        };
      }
    }

    return { detected: false };
  }

  detectFakey(candles: Candle[]): PatternResult {
    if (candles.length < 3) return { detected: false };

    const C0 = analyzeCand(candles[candles.length - 1]);
    const C1 = analyzeCand(candles[candles.length - 2]);
    const C2 = analyzeCand(candles[candles.length - 3]);

    const isC1Inside = C1.high <= C2.high && C1.low >= C2.low;

    if (!isC1Inside) return { detected: false };

    const probeBelow = C0.low < C1.low;
    const closeAbove = C0.close > C1.high;

    // –õ–û–ù–ì: C2 –∑–µ–ª–µ–Ω–∞—è, C1 –∫—Ä–∞—Å–Ω–∞—è, C0 –∑–µ–ª–µ–Ω–∞—è
    if (probeBelow && closeAbove && C2.isGreen && C1.isRed && C0.isGreen) {
      console.log(`‚úÖ [Pattern] Fakey BUY detected (GREEN-RED-GREEN)`);
      return {
        detected: true,
        type: 'fakey_buy',
        direction: 'LONG',
        entryPrice: C0.close,
      };
    }

    const probeAbove = C0.high > C1.high;
    const closeBelow = C0.close < C1.low;

    // –®–û–†–¢: C2 –∫—Ä–∞—Å–Ω–∞—è, C1 –∑–µ–ª–µ–Ω–∞—è, C0 –∫—Ä–∞—Å–Ω–∞—è
    if (probeAbove && closeBelow && C2.isRed && C1.isGreen && C0.isRed) {
      console.log(`‚úÖ [Pattern] Fakey SELL detected (RED-GREEN-RED)`);
      return {
        detected: true,
        type: 'fakey_sell',
        direction: 'SHORT',
        entryPrice: C0.close,
      };
    }

    return { detected: false };
  }

  detectPPR(candles: Candle[]): PatternResult {
    if (candles.length < 2) return { detected: false };

    const C0 = analyzeCand(candles[candles.length - 1]);
    const C1 = analyzeCand(candles[candles.length - 2]);

    // –õ–û–ù–ì: C1 –∫—Ä–∞—Å–Ω–∞—è, C0 –∑–µ–ª–µ–Ω–∞—è, –∑–∞–∫—Ä–µ–ø–ª—è–µ—Ç—Å—è –≤—ã—à–µ –º–∞–∫—Å–∏–º—É–º–∞
    if (C0.close > C1.high && C1.isRed && C0.isGreen) {
      console.log(`‚úÖ [Pattern] –ü–ü–† BUY detected (RED->GREEN)`);
      return {
        detected: true,
        type: 'ppr_buy',
        direction: 'LONG',
        entryPrice: C0.close,
      };
    }

    // –®–û–†–¢: C1 –∑–µ–ª–µ–Ω–∞—è, C0 –∫—Ä–∞—Å–Ω–∞—è, –∑–∞–∫—Ä–µ–ø–ª—è–µ—Ç—Å—è –Ω–∏–∂–µ –º–∏–Ω–∏–º—É–º–∞
    if (C0.close < C1.low && C1.isGreen && C0.isRed) {
      console.log(`‚úÖ [Pattern] –ü–ü–† SELL detected (GREEN->RED)`);
      return {
        detected: true,
        type: 'ppr_sell',
        direction: 'SHORT',
        entryPrice: C0.close,
      };
    }

    return { detected: false };
  }

  detectEngulfing(candles: Candle[]): PatternResult {
    if (candles.length < 2) return { detected: false };

    const C0 = analyzeCand(candles[candles.length - 1]);
    const C1 = analyzeCand(candles[candles.length - 2]);

    const engulfs = C0.high >= C1.high && C0.low <= C1.low;

    if (engulfs && C0.isGreen && C1.isRed) {
      const strongBody = C0.body >= C1.body && C0.close > C1.open;
      if (strongBody) {
        console.log(`‚úÖ [Pattern] Engulfing BUY detected`);
        return {
          detected: true,
          type: 'engulfing_buy',
          direction: 'LONG',
          entryPrice: C0.close,
        };
      }
    }

    if (engulfs && C0.isRed && C1.isGreen) {
      const strongBody = C0.body >= C1.body && C0.close < C1.open;
      if (strongBody) {
        console.log(`‚úÖ [Pattern] Engulfing SELL detected`);
        return {
          detected: true,
          type: 'engulfing_sell',
          direction: 'SHORT',
          entryPrice: C0.close,
        };
      }
    }

    return { detected: false };
  }

  detectAllPatterns(candles: Candle[]): PatternResult[] {
    console.log(`\nüîç [Pattern Detection] Starting pattern detection with ${candles.length} candles`);
    
    const results: PatternResult[] = [];

    // –ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–∞ (EMA 50/200)
    const trend = analyzeTrend(candles);
    
    // –ê–Ω–∞–ª–∏–∑ S/R –∑–æ–Ω
    const srAnalysis = analyzeSRZones(candles);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—ä–µ–º–∞
    const hasGoodVolume = isVolumeAboveAverage(candles);
    if (!hasGoodVolume) {
      console.log(`‚ùå [Filter] REJECTED - Volume below average, skipping all patterns`);
      return results;
    }

    // –î–µ—Ç–µ–∫—Ç–∏—Ä—É–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã –∏ –æ—Ü–µ–Ω–∏–≤–∞–µ–º –∏—Ö
    const patterns = [
      this.detectPinBar(candles),
      this.detectFakey(candles),
      this.detectPPR(candles),
      this.detectEngulfing(candles),
    ];

    for (const pattern of patterns) {
      if (!pattern.detected || !pattern.direction || !pattern.entryPrice) continue;

      // –î–æ–±–∞–≤–ª—è–µ–º S/R –∞–Ω–∞–ª–∏–∑ –∫ –ø–∞—Ç—Ç–µ—Ä–Ω—É
      pattern.srAnalysis = srAnalysis;

      // === SCORING SYSTEM ===
      let score = 0;
      const patternName = pattern.type?.replace('_buy', '').replace('_sell', '').toUpperCase();
      
      console.log(`\nüíØ [Scoring] ${patternName} ${pattern.direction}:`);

      // 1Ô∏è‚É£ S/R ZONE SCORE (–ö–†–ò–¢–ò–ß–ù–´–ô GATING –§–ò–õ–¨–¢–†)
      const distanceToSupport = getDistanceToZone(pattern.entryPrice, srAnalysis.nearestSupport);
      const distanceToResistance = getDistanceToZone(pattern.entryPrice, srAnalysis.nearestResistance);
      
      const isNearSupport = distanceToSupport !== null && distanceToSupport < 0.005; // < 0.5%
      const isNearResistance = distanceToResistance !== null && distanceToResistance < 0.005;

      // GATING: –û—Ç–∫–ª–æ–Ω—è–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã —É –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û–ô –∑–æ–Ω—ã
      if (pattern.direction === 'LONG') {
        if (isNearResistance && !isNearSupport) {
          // LONG —É Resistance - REJECT
          console.log(`   ‚ùå S/R GATING: REJECT - LONG —É Resistance –∑–æ–Ω—ã (–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞)\n`);
          continue;
        }
        if (isNearSupport) {
          score += 100;
          console.log(`   ‚úÖ S/R: +100 (—É Support –∑–æ–Ω—ã ${srAnalysis.nearestSupport?.price.toFixed(4)})`);
        } else {
          score += 50;
          console.log(`   ‚ö†Ô∏è S/R: +50 (–ù–ï —É –∑–æ–Ω—ã - —Å–ª–∞–±—ã–π —Å–∏–≥–Ω–∞–ª)`);
        }
      } else { // SHORT
        if (isNearSupport && !isNearResistance) {
          // SHORT —É Support - REJECT
          console.log(`   ‚ùå S/R GATING: REJECT - SHORT —É Support –∑–æ–Ω—ã (–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞)\n`);
          continue;
        }
        if (isNearResistance) {
          score += 100;
          console.log(`   ‚úÖ S/R: +100 (—É Resistance –∑–æ–Ω—ã ${srAnalysis.nearestResistance?.price.toFixed(4)})`);
        } else {
          score += 50;
          console.log(`   ‚ö†Ô∏è S/R: +50 (–ù–ï —É –∑–æ–Ω—ã - —Å–ª–∞–±—ã–π —Å–∏–≥–Ω–∞–ª)`);
        }
      }

      // 2Ô∏è‚É£ EMA TREND SCORE
      const trendAligned = 
        (pattern.direction === 'LONG' && trend.isUptrend) ||
        (pattern.direction === 'SHORT' && trend.isDowntrend);
      
      const weakTrend = 
        (pattern.direction === 'LONG' && trend.currentPrice > trend.ema50 && Math.abs(trend.ema50 - trend.ema200) / trend.ema200 < 0.02) ||
        (pattern.direction === 'SHORT' && trend.currentPrice < trend.ema50 && Math.abs(trend.ema50 - trend.ema200) / trend.ema200 < 0.02);

      if (trendAligned) {
        score += 30;
        console.log(`   ‚úÖ Trend: +30 (—Å–∏–ª—å–Ω—ã–π —Ç—Ä–µ–Ω–¥ aligned)`);
      } else if (weakTrend) {
        score += 15;
        console.log(`   ‚ö†Ô∏è Trend: +15 (—Å–ª–∞–±—ã–π —Ç—Ä–µ–Ω–¥)`);
      } else {
        score += 0;
        console.log(`   ‚ùå Trend: +0 (–ø—Ä–æ—Ç–∏–≤ —Ç—Ä–µ–Ω–¥–∞)`);
      }

      // 3Ô∏è‚É£ VOLUME SCORE
      const volumes = candles.map((c) => parseFloat(c.volume));
      const last20Volumes = volumes.slice(volumes.length - 21, volumes.length - 1);
      const avgVolume = last20Volumes.reduce((sum, vol) => sum + vol, 0) / last20Volumes.length;
      const currentVolume = volumes[volumes.length - 1];
      const volumeRatio = currentVolume / avgVolume;

      if (volumeRatio > 1.5) {
        score += 30;
        console.log(`   ‚úÖ Volume: +30 (${volumeRatio.toFixed(2)}x average)`);
      } else if (volumeRatio > 1.0) {
        score += 15;
        console.log(`   ‚ö†Ô∏è Volume: +15 (${volumeRatio.toFixed(2)}x average)`);
      } else {
        score += 0;
        console.log(`   ‚ùå Volume: +0 (${volumeRatio.toFixed(2)}x average)`);
      }

      // 4Ô∏è‚É£ SHARP MOVE SCORE
      const hasSharpMove = hasSharpMoveBefore(candles, pattern.direction);
      if (!hasSharpMove) {
        score += 20;
        console.log(`   ‚úÖ Sharp Move: +20 (–Ω–µ—Ç profit-taking)`);
      } else {
        score += 0;
        console.log(`   ‚ùå Sharp Move: +0 (–æ–±–Ω–∞—Ä—É–∂–µ–Ω profit-taking)`);
      }

      // === –ò–¢–û–ì–û–í–ê–Ø –û–¶–ï–ù–ö–ê ===
      pattern.score = score;
      console.log(`   üéØ –ò–¢–û–ì–û: ${score} –±–∞–ª–ª–æ–≤`);

      // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥: 130 –±–∞–ª–ª–æ–≤ (GOOD signal)
      if (score >= 130) {
        const quality = score >= 150 ? '‚≠ê‚≠ê‚≠ê PREMIUM' : '‚≠ê‚≠ê GOOD';
        console.log(`   ‚úÖ ${quality} - —Å–∏–≥–Ω–∞–ª –ü–†–ò–ù–Ø–¢!\n`);
        results.push(pattern);
      } else {
        console.log(`   ‚ùå –û–¢–ö–õ–û–ù–ï–ù (score < 130)\n`);
      }
    }

    console.log(`üìä [Pattern Detection] Total patterns passed filters: ${results.length}`);
    return results;
  }
}

export const patternDetector = new PatternDetector();
